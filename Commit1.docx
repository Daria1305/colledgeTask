івень, внісши до нього деякі удосконалення або виправляючи помилки, або іноді навіть викинути проект і почати все спочатку, тому що розробник раптово побачив кращий підхід.
Якщо ж головна частина програми вже запрограмована і Відтестований, то виникає серйозний опір будь-яким поліпшень її структури. У кінцевому підсумку за рахунок таких поліпшень зазвичай можна заощадити більше, ніж ті кілька днів або тижнів, які розраховує виграти проектувальник, приступаючи до програмування занадто рано.


4.3 Технологія висхідного і низхідного тестування


При плановому підході програма перевіряється послідовно блок за блоком, причому якщо програма складається з центрального блоку, який проводить звернення до периферійних блокам, мало пов'язаних один з одним, то можливі такі два основних підходи до контролю такої програми, два основних напрямки тестування:

· від периферії до центру (висхідне тестування) або, навпаки,

· від центру до периферії (спадне тестування).

При першому, висхідному тестуванні, вживаному зазвичай для невеликих програм, спочатку тестують окремі периферійні блоки, а потім переходять до тестування центральній частині, яка, зрозуміло, взаємодіє тільки з налагодженими вже блоками.

При низхідному тестуванні, використовуваному для досить великих програм, паралельно з контролем периферійних блоків (або навіть до початку їх контролю) виробляється і контроль центрального блоку, виконуваного на комп'ютері спільно з імітаторами периферійних блоків, званих заглушками. У завдання імітаторів входить моделювання роботи відповідних блоків з метою підтримати функціонування центрального блоку. Зазвичай заглушки видають найпростіший результат, наприклад константу і повідомлення про факт своєї участі в роботі. Замість постійної величини на найбільш пізній стадії тестування може видаватися і випадкова величина в необхідному діапазоні.

Наприклад, для початкового контролю програми, що включає в якості одного зі своїх блоків обчислення певного інтеграла, заглушка такого блоку може повертати константу. У свою чергу, блок інтегрування сам має периферійний блок обчислення значень підінтегральної функції, в якості заглушки якого спочатку також може бути взята константа або найпростіша функціональна залежність.

На жаль, часто невірно розуміють функції, виконувані заглушками. Так, часом можна почути, що заглушка повинна виконувати лише запис повідомлення, що встановлює: Модуль підключився raquo ;. У більшості випадків ці твердження помилкові. Коли модуль A викликає модуль B, A припускає, що B виконує якусь роботу, тобто модуль A отримує результати роботи модуля B. Коли ж модуль B просто повертає управління або видає деяке повідомлення без передачі в A певних осмислених результатів, модуль A працює невірно НЕ внаслідок помилок у самому модулі, а через невідповідність йому модуля-заглушки. Більше того, результат може виявитися незадовільним, якщо відповідь модуля-заглушки не змінюється в залежності від умов тесту. Якщо заглушка завжди повертає один і той же фіксований результат замість конкретного значення, передбачуваного зухвалим модулем саме в цьому виклику, то викликає модуль спрацює як помилковий (наприклад, зациклиться) або видасть невірне вихідне значення. Отже,



Практично, обидва ці способи рідко використовуються в чистому вигляді, окремо один від одного. Зазвичай до часу, коли приступають до контролю центрального блоку, якісь найпростіші периферійні блоки вже налагоджені автономно, і немає необхідності моделювати їх роботу і розробляти заглушки.

Перевагою ранньої налагодження центрального блоку при низхідному тестуванні є те, що програміст швидко отримує можливість перевірити периферійні блоки в умовах, які в необхідній мірі наближені до реальних. Дійсно, центральний блок, забезпечений хоча б і найпростішими функціональними можливостями, можна розглядати як реальне середовище, в яку занурюються Отлаживаются блоки, додаються до центральної частини. Додавання Отлаживаются блоків зручно робити по одному для якнайшвидшого пошуку помилок, що виникають при стикуванні з центральним блоком. Підключення кожного нового блоку до центральної частини дозволяє поступово ускладнювати випробування, яким піддається тестуєма програма.

Суворої, коректної процедури підключення чергового послідовно модуля, що тестується не існує. Єдине правило, яким слід керуватися привиборі чергового модуля, полягає в тому, що їм має бути один з модулів, що викликаються модулем, попередньо пройшли тестування.

Запам'ятайте, що навіть якщо зміни вносяться тільки в одну підпрограму, то повторному тестуванню підлягає вся система. Цей процес називається тестуванням з поверненням....
Перевіряти роботу тільки зміненої підпрограми недостатньо! Недостатньо повне тестування такого роду підвищує ймовірність невдач.
Проведемо порівняння низхідного і висхідного тестування [Таблиця 1].

Значне підвищення коректності та надійності програм досягається застосуванням подвійного або N-кратного програмування (Duplication Check - подвійний прорахунок, подвійна перевірка).

При цьому методі при різних алгоритмах і на різних мовах програмування створюється кілька варіантів програми. Ці варіанти реалізують одні й ті ж функції і за певних тестових даних повинні видавати тотожні результати. Різниця результатів при тестуванні вказує на наявність помилок, принаймні, в одному з варіантів. Зазвичай при розробці варіантів програми використовується один і той же алгоритм, але програми створюються на різних мовах, різних комп'ютерах і різними програмістами. На практиці застосовується програмування з N=2. Практично дуже рідкісні випадки, коли реальна програма створювалася в трьох і більше варіантах.

На закінчення зазначимо, що якщо виконання тесту приносить результати, які не відповідають передбачуваним, то це означає, що:

· Або модуль має помилку;

· Або невірні передбачувані результати (помилки в тесті).

Для усунення такого роду непорозумінь потрібно ретельно перевіряти набір тестів ( тестувати тести).


. Тестування методами «білого», «чорного» і «сірого ящика»


5.1 Тестування методом «білого ящика»


При тестуванні методом «білого ящика» розробник тесту має доступ до вихідного тестируемому кодом і може компонувати з ним код тестів. Така ситуація типова для модульного тестування, при якому тестуються тільки окремі частини системи. При тестуванні методом «білого ящика» може використовуватися знання про внутрішній устрій перевіряється ПЗ, у тому числі і для організації перевірки обробки допустимих, граничних і некоректних даних. Крім того, даний вид тестування дозволяє оцінити рівень покриття коду тестами.

Термін білий ящик означає, що при розробці тестових випадків тестувальники використовують будь-які доступні відомості про внутрішню структуру чи коді. Технології, застосовувані під час тестування білого ящика raquo ;, зазвичай називають технологіями статичного тестування.

Цей метод не ставить мети виявлення синтаксичних помилок, так як дефекти такого роду звичайно виявляє компілятор. Методи білого ящика спрямовані на локалізацію помилок, які складніше виявити, знайти і зафіксувати. З їх допомогою можна виявити логічні помилки і перевірити ступінь покриття тестами.

Тестові процедури, пов'язані з використанням стратегії білого ящика, використовують керуючу логіку процедур. Вони надають ряд послуг, в тому числі:

· Дають гарантію того, що всі незалежні шляхи в модулі перевірені принаймні один раз.

· Перевіряють всі логічні рішення на предмет того, істини вони чи хибні.

· Виконують всі цикли всередині операційних кордонів і з використанням граничних значень.

· Досліджують структури внутрішніх даних із цілі перевірки їх достовірності.

Тестування допомогою білого ящика, як правило, включає в себе стратегію модульного тестування, при якому тестування ведеться на модульному або функціональному рівні та роботи з тестування направлені на дослідження внутрішнього устрою модуля. Даний тип тестування називають також модульним тестуванням, тестуванням прозорого ящика (clear box) або прозорим (translucent) тестуванням, оскільки співробітники, які проводять тестування, мають доступ до програмного коду і можуть бачити роботу програми зсередини. Даний підхід до тестування відомий також як структурний підхід.

На цьому рівні тестування перевіряється керуюча логіка, що виявляється на модульному рівні. Тестові драйвери використовуються для того, щоб всі шляхи в даному модулі були перевірені хоча б один раз, всі логічні рішення розглянуті у всіляких умовах, цикли були виконані з використанням верхніх і нижніх меж і роконтроліровани структури внутрішніх даних.

Методи тестування на основі стратегії білого ящика:

· Ввід невірних значень. При введенні невірних значень тестувальник змушує коди повернення показувати помилки і дивиться на реакцію коду. Це хороший спосіб моделювання певних подій, наприклад переповнення диска, нестачі пам'яті й т.д. Популярним методом є заміна alloc () функцією, яка повертає значення NULL в 10% випадків з метою з'ясування, скільки збоїв буде в результаті. Такий підхід ще називають тестуванням помилкових вхідних даних. При та...
кому тестуванні перевіряється обробка як вірних, так і невірних вхідних даних. Тестувальники можуть вибрати, які значення перевіряють діапазон вхідних/вихідних параметрів, а також значення, що виходять за межу діапазону.
· Модульне тестування. При створенні коду кожного модуля програмного продукту проводиться модульне тестування для перевірки того, що код працює вірно і коректно реалізує архітектуру. При модульному тестуванні новий код перевіряється на відповідність докладного опису архітектури; обстежуються шляху в коді, встановлюється, що екрани, спадаючі меню і повідомлення належним чином відформатовані; перевіряються діапазон і тип даних, що вводяться, а також те, що кожен блок коду, коли потрібно, генерує виключення і повертає помилки (Еггог returns). Тестування кожного модуля програмного продукту проводиться для того, щоб перевірити коректність алгоритмів і логіки і те, що програмний модуль задовольняє пропонованим вимогам і забезпечує необхідну функціональність. За підсумками модульного тестування фіксуються помилки, що відносяться до логіки програми, перевантаження і виходу з діапазону, часу роботи і витоку пам'яті.

· Тестування обробки помилок. При використанні цього методу зізнається, що нереально на практиці перевірити кожне можливе умова виникнення помилки. З цієї причини програма обробки помилок може згладити наслідки при виникненні несподіваних помилок. Тестувальник зобов'язаний переконатися в тому, що додаток належним чином видає повідомлення про помилку. Так, додаток, що повідомляє про системну помилку, що виникла через проміжного програмного забезпечення представляє невелику цінність, як для кінцевого користувача, так і для тестувальника.

· Витік пам'яті. При тестуванні витоку пам'яті додаток досліджується з метою виявлення ситуацій, при яких додаток не звільняє виділену пам'ять, внаслідок чого знижується продуктивність або виникає тупикова ситуація. Дана технологія застосовується як для тестування версії додатка, так і для тестування готового програмного продукту. Можливе застосування інструментів тестування. Вони можуть стежити за використанням пам'яті програми протягом декількох годин або навіть днів, щоб перевірити, чи буде зростати обсяг використовуваної пам'яті. З їх допомогою можна також виявити ті оператори програми, які не звільняють виділену пам'ять.

· Комплексне тестування. Метою комплексного тестування є перевірка того, що кожен модуль програмного продукту коректно узгоджується з іншими модулями продукту. При комплексному тестуванні може використовуватися технологія обробки зверху вниз і знизу вгору, при якій кожен модуль, що є листом в дереві системи, інтегрується з наступним модулем нижчого або більш високого рівня, поки не буде створено дерево програмного продукту. Ця технологія тестування спрямована на перевірку не тільки тих параметрів, які передаються між двома компонентами, але й на перевірку глобальних параметрів і у випадку об'єктно-орієнтованого додатки, всіх класів верхнього рівня.

· Тестування ланцюжків. Тестування ланцюжків передбачає перевірку групи модулів, що складають функцію програмного продукту. Ці дії відомі ще як модульне тестування, з його допомогою забезпечується адекватне тестування компонентів системи. Дане тестування виявляє, чи достатньо надійно працюють модулі для того, щоб утворити єдиний модуль, і чи видає модуль програмного продукту точні і що погодяться.

· Дослідження покриття. При виборі інструмента для дослідження покриття важливо, щоб група тестування проаналізувала тип покриття, необхідний для програми. Дослідження покриття можна провести за допомогою різних технологій. Метод покриття операторів часто називають С1, що також означає покриття вузлів. Ці виміри показують, чи був перевірений кожен виконуваний оператор. Даний метод тестування зазвичай використовує програму протоколювання (profiler) продуктивності.

· Покриття рішень. Метод покриття рішень спрямований на визначення (у відсотковому співвідношенні) всіх можливих результатів рішень, які були перевірені за допомогою комплекту тестових процедур. Метод покриття рішень іноді відносять до покриттю гілок і називають С2. Він вимагає: щоб кожна точка входу і виходу в програмі була досягнута хоча б один раз, щоб всі можливі умови для рішень в програмі були перевірені не менше одного разу і щоб кожне рішення в програмі хоча б раз було протестовано при використанні всіх можливих результатів.

· Покриття умов. Покриття умов схоже на покриття рішень. Воно спрямоване на перевірку точності істинних або помилкових результатів кожного логічного виразу. Цей метод включає в себе тести, які перевіряють вираження незалежно один від одного. Результати цих перевірок аналогічні тим, що одержують при застосуванні методу покриття рішень, за винятком того, що метод пок...
риття рішень більш чутливий до керуючої логіці програми.

5.2 Тестування методом «чорного ящика»


При тестуванні методом «чорного ящика» тестувальник має доступ до ПЗ тільки через ті ж інтерфейси, що і замовник або користувач, або через зовнішні інтерфейси, що дозволяють іншого комп'ютера або іншому процесу підключитися до системи для тестування. Як правило, тестування «чорного ящика» ведеться з використанням специфікацій чи інших документів, що описують вимоги до системи. У даному вигляді тестування намагаються забезпечити покриття вимог і вхідних даних.

Тестування на основі стратегії чорного ящика можливе лише за наявності встановлених відкритих інтерфейсів, таких як інтерфейс користувача або програмний інтерфейс додатку (API). Якщо тестування на основі стратегії білого ящика досліджує внутрішню роботу програми, то методи тестування чорного ящика порівнюють поведінку додатки з відповідними вимогами. Крім того, ці методи зазвичай спрямовані на виявлення трьох основних видів помилок: функціональності, підтримуваної програмним продуктом; вироблених обчислень; допустимого діапазону або області дії значень даних, які можуть бути опрацьовані програмним продуктом. На цьому рівні тестувальники не досліджують внутрішню роботу компонентів програмного продукту, тим не менше вони перевіряються неявно. Група тестування вивчає вхідні і вихідні дані програмного продукту. У цьому ракурсі тестування за допомогою методів чорного ящика розглядається як синонім тестування на рівні системи, хоча методи чорного ящика можуть також застосовуватися під час модульного або компонентного тестування.

При тестуванні методами чорного ящика важлива участь користувачів, оскільки саме вони найкраще знають, яких результатів слід очікувати від бізнес-функцій. Ключем до успішного завершення системного тестування є коректність даних. Тому на фазі створення даних для тестування вкрай важливо, щоб кінцеві користувачі надали якомога більше вхідних даних.

Тестування за допомогою методів чорного ящика спрямоване на одержання множин вхідних даних, які найбільш повно перевіряють всі функціональні вимоги системи. Це не альтернатива тестуванню за методом білого ящика. Цей тип тестування націлений на пошук помилок, які відносяться до цілого ряду категорій, серед них:

v Невірна або пропущена функціональність

v Помилки інтерфейсу

v Проблеми зручності використання

v Методи тестування на основі Автоматизовані інструменти

v Помилки в структурах даних або помилки доступу до зовнішніх баз даних

v Проблеми зниження продуктивності та інші помилки продуктивності

v Помилки завантаження

v Помилки багатокористувацького доступу

v Помилки ініціалізації та завершення

v Проблеми збереження резервних копій і здатності до відновлення роботи

v Проблеми безпеки

v Методи тестування на основі стратегії чорного ящика

Рішення цих помилок може бути знайдено за допомогою таких методів тестування:

? Еквівалентна розбиття. Повне тестування вхідних даних, як правило, нездійсненно. Тому слід проводити тестування з використанням підмножини вхідних даних.

При тестуванні помилок, пов'язаних з виходом за межі області допустимих значень, застосовують три основних типи еквівалентних класів: значення всередині межі діапазону, за межею діапазону і на кордоні. Виправдовує себе практика створення тестових процедур, які перевіряють граничні випадки плюс/мінус один щоб уникнути пропуску помилок «на одиницю більше» або «на одиницю менше». Крім розроблення тестових процедур, що використовують сильно структуровані класи еквівалентності, група тестування повинна провести дослідницьке тестування. Тестові процедури, при виконанні яких видаються очікувані результати, називаються правильними тестами. Тестові процедури, проведення яких має призвести до помилки, носять назву неправильних тестів.

? Аналіз граничних значень. Аналіз граничних значень можна застосувати як на структурному, так і на функціональному рівні тестування. Межі визначають дані трьох типів: правильні, неправильні і лежать на границі. Тестування кордонів використовує значення, що лежать всередині або на кордоні (наприклад, крайні точки), і максимальні/мінімальні значення (наприклад, довжини полів). При такому дослідженні завжди повинні враховуватися значення на одиницю більше і менше граничного. При тестуванні за межами кордону використовується репрезентативний зразок даних, що виходять за межу, тобто невірні значення.

? Діаграми при...

чинно-наслідкових зв'язків. Складання діаграм причинно-наслідкових зв'язків - це метод, що дає чітке уявлення про логічних умовах і відповідних діях. Метод передбачає чотири етапи. Перший етап полягає в складанні переліку причин (умов введення) і наслідків (дій) для модуля й у присвоєнні ідентифікатора кожному модулю. На другому етапі розробляється діаграма причинно-наслідкових зв'язків. На третьому етапі діаграма перетворюється в таблицю рішень. Четвертий етап включає в себе встановлення причин і наслідків в процесі читання специфікації функцій. Кожній причини і слідству присвоюється власний ідентифікатор. Причини перераховуються в стовпчику з лівого боку аркуша паперу, а слідства - з правого. Потім причини і наслідки з'єднуються лініями так, щоб були відображені наявні між ними відповідності. На діаграмі проставляються булеві вирази, які об'єднують дві або більше причин, пов'язаних зі слідством. Далі правила таблиці рішень перетворюються в тестові процедури.
? Системне тестування. Термін «системне тестування» часто вживається до?? до синонім «тестування за допомогою методів чорного ящика», оскільки під час системного тестування група тестування розглядає в основному «зовнішня поведінка» додатка. Системне тестування включає в себе кілька підтипів тестування, у тому числі функціональне, регресійне, безпеки, перевантажень, продуктивності, зручності використання, випадкове, цілісності даних, перетворення даних, збереження резервних копій і здатності до відновлення, готовності до роботи, приймально-здавальні випробування і альфа/бета тестування.

? Функціональне тестування. Функціональне тестування перевіряє системне додаток відносно функціональних вимог з метою виявлення невідповідності вимогам кінцевого користувача. Для більшості програм тестування програмного продукту даний метод тестування є головним. Його основне завдання - оцінка того, чи працює додаток відповідно до ставляться.

? Регресійне тестування. Сенс проведення тестування полягає у виявленні дефектів, їх документуванні та відстеженні аж до усунення. Тестувальник повинен бути впевнений в тому, що заходи, прийняті для усунення знайдених помилок, які не породять у свою чергу нових помилок в інших областях системи. Регресійне тестування дозволяє з'ясувати, чи не з'явилися які-небудь помилки в результаті ліквідації вже виявлених помилок. Саме для регресійного тестування застосування інструментів автоматизованого тестування дає найбільшу віддачу. Всі створені раніше скрипти можна використовувати знову для підтвердження того, що в результаті змін, внесених при усуненні помилки, чи не з'явилися нові дефекти. Ця мета легко досяжна, оскільки скрипти можна виконувати без ручного втручання і використовувати стільки разів, скільки необхідно для виявлення помилок.

? Тестування безпеки. Тестування безпеки включає в себе перевірку роботи механізмів доступу до системи і до даних. Для цього придумують тестові процедури, які намагаються подолати захист системи. Тестувальник перевіряє ступінь безпеки й обмеження доступу, виявляючи таким чином відповідність встановленим вимогам до безпеки і всім застосовуваним правилам з безпеки системи.

? Тестування перевантажень. При тестуванні перевантажень виконується перевірка системи без врахування обмежень архітектури з цілі виявлення технічних обмежень системи. Ці тести проводяться на піку обробки транзакцій і при безперервному завантаженні великого обсягу даних. Тестування перевантажень вимірює пропускну спроможність системи та її еластичність (resiliency) на всіх апаратних платформах. Цей метод передбачає одночасне звернення з боку багатьох користувачів до певних функцій системи, причому деякі вводять значення, що виходять за межі норми. Від системи потрібна обробка величезної кількості даних або виконання великого числа функціональних запитів протягом короткого періоду часу.

? Тестування продуктивності. Тести продуктивності перевіряють, чи задовольняє системне додаток вимогам по продуктивності. Застосовуючи тестування продуктивності, можна заміряти і скласти звіти за такими показниками, як швидкість передачі вхідних і вихідних даних, загальне число дій по введенню і виведенню даних, середній час, що витрачається базою даних на відгук на запит, і інтенсивність використання центрального процесора. Як правило, для автоматичної перевірки ступеня продуктивності, проведеної в рамках тестування продуктивності, використовуються ті ж інструменти, що і при тестуванні перевантажень.

? Тестування зручності використання. Тести зручності використання спрямовані на підтвердження простоти застосування системи і того, що користувальницький інтерфейс виглядає привабливо. Такі тести враховують людський фактор у роботі системи. Тестувальника потрібно оцінити програму з точки зору кінцевого користувача.
